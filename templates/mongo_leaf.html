<!DOCTYPE html>
<html lang="en">
    <head>
	<style type="text/css">

	 .axis text {
	     font: 10px sans-serif;
	 }

	 .axis path,
	 .axis line {
	     fill: none;
	     stroke: #000;
	     shape-rendering: crispEdges;
	 }

	 .hexagon {
	     fill: #20FF20;
	     stroke: #000;
	     stroke-width: .5px;
	 }
	 #mapid { height: 600px; width: 600px;}
	 #tooltip {
             opacity: .9;
             background: #333;
             padding: 5px;
             border: 1px solid lightgrey;
             border-radius: 5px;
             position: absolute;
             z-index: 10;
             visibility: hidden;
             pointer-events: none;
	 }

	</style>
        <meta charset="utf-8">
        <title>Map Test</title>
	<link rel="stylesheet" href="{{ url_for('static', filename='leaflet.css') }}" />
	<script type="text/javascript" src="{{ url_for('static', filename='d3.v3.js') }}" charset="utf-8"></script>
	<script type="text/javascript" src="{{ url_for('static', filename='d3.hexbin.min.js') }}" charset="utf-8"></script>
	<script type="text/javascript" src="{{ url_for('static', filename='leaflet.js') }}" charset="utf-8"></script>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.2/jquery.min.js"></script>
    </head>
    <body>
	<div id="mapid"></div>
	<script type="text/javascript">

	 //**********************************************************************************
	 //********  LEAFLET HEXBIN LAYER CLASS *********************************************
	 //**********************************************************************************
	 L.HexbinLayer = L.Class.extend({
	     includes: L.Mixin.Events,
	     initialize: function (rawData, options) {
		 this.levels = {};
		 this.layout = d3.hexbin().radius(10);
		 this.rscale = d3.scale.sqrt().range([0, 10]).clamp(true);
		 this.rwData = rawData;
		 this.config = options;
	     },
	     project: function(x) {
		 var point = this.map.latLngToLayerPoint([x[1], x[0]]);
		 return [point.x, point.y];
	     },
	     getBounds: function(d) {
		 var b = d3.geo.bounds(d)
		 return L.bounds(this.project([b[0][0], b[1][1]]), this.project([b[1][0], b[0][1]]));
	     },
	     update: function () {
		 var pad = 100, xy = this.getBounds(this.rwData), zoom = this.map.getZoom();

		 this.container
		     .attr("width", xy.getSize().x + (2 * pad))
		     .attr("height", xy.getSize().y + (2 * pad))
		     .style("margin-left", (xy.min.x - pad) + "px")
		     .style("margin-top", (xy.min.y - pad) + "px");

		 if (!(zoom in this.levels)) {
		     this.levels[zoom] = this.container.append("g").attr("class", "zoom-" + zoom);
		     this.genHexagons(this.levels[zoom]);
		     this.levels[zoom].attr("transform", "translate(" + -(xy.min.x - pad) + "," + -(xy.min.y - pad) + ")");
		 }
		 if (this.curLevel) {
		     this.curLevel.style("display", "none");
		 }
		 this.curLevel = this.levels[zoom];
		 this.curLevel.style("display", "inline");
	     },
	     genHexagons: function (container) {
		 var data = this.rwData.features.map(function (d) {
		     var coords = this.project(d.geometry.coordinates)
		     return [coords[0],coords[1], d.properties];
		 }, this);

		 var bins = this.layout(data);
		 var hexagons = container.selectAll(".hexagon").data(bins);

		 var counts = [];
		 bins.map(function (elem) { counts.push(elem.length) });
		 this.rscale.domain([0, (d3.mean(counts) + (d3.deviation(counts) * 3))]);

		 var path = hexagons.enter().append("path").attr("class", "hexagon");
		 this.config.style.call(this, path);

		 that = this;
		 hexagons
		     .attr("d", function(d) { return that.layout.hexagon(that.rscale(d.length)); })
		     .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; })
		     .on("mouseover", function (d) { 
			 var s=0, k=0;
			 d.map(function(e){
			     if (e.length === 3) e[2].group === 1 ? ++k : ++s;
			 });
			 that.config.mouse.call(this, [s,k]);
			 d3.select("#tooltip")
			   .style("visibility", "visible")
			   .style("top", function () { return (d3.event.pageY - 130)+"px"})
			   .style("left", function () { return (d3.event.pageX - 130)+"px";})
		     })
		     .on("mouseout", function (d) { d3.select("#tooltip").style("visibility", "hidden") });
	     },
	     addTo: function (map) {
		 map.addLayer(this);
		 return this;
	     },
	     onAdd: function (map) {
		 this.map = map;
		 var overlayPane = this.map.getPanes().overlayPane;

		 if (!this.container || overlayPane.empty) {
		     this.container = d3.select(overlayPane)
					.append('svg')
					.attr("id", "hex-svg")
					.attr('class', 'leaflet-layer leaflet-zoom-hide');
		 }
		 map.on({ 'moveend': this.update }, this);
		 this.update();
	     }
	 });

	 L.hexbinLayer = function (data, styleFunction) {
             return new L.HexbinLayer(data, styleFunction);
	 };
	 
	 // Hexbin map
	 // http://www.delimited.io/blog/2013/12/1/hexbins-with-d3-and-leaflet-maps
	 //Width and height
	 var w = 600;
	 var h = 600;
	 var margin = {top: 20, right: 20, bottom: 30, left: 40};
	 w = w - margin.right - margin.left;
	 h = h - margin.top - margin.bottom;
	 // load the external data
	 var myjson = "data";
	 d3.json(myjson, function(error, coords) {

	     var projection = d3.geo.mercator()
				.scale(70000)
				.rotate([-53.45, -14.57])
				.translate([w / 2, h / 2])
				.precision(.1);

	     console.log(projection([0,0]));
	     console.log(projection([53.4,14.55]));
	     // Summarize
	     var lat_min = d3.min(coords, function(d) {
		 return Number(d.data_lat);
	     });
	     var lat_max = d3.max(coords, function(d) {
		 return Number(d.data_lat);
	     });
	     var delta_lat = lat_max - lat_min
	     
	     var lon_min = d3.min(coords, function(d) {
		 return Number(d.data_lon);
	     });
	     var lon_max = d3.max(coords, function(d) {
		 return Number(d.data_lon);
	     });
	     var delta_lon = lon_max - lon_min
	     console.log(lat_min, lat_max);
	     console.log(lon_min, lon_max);

	     var dd = [];
	     coords.forEach(function(d) {
		 var p =projection([d.data_lat, d.data_lon]);
		 // console.log(p);
		 dd.push([h-p[0], w-p[1]]);
	     }
	     );
	     //console.log(dd);
	     //Create SVG element

	     // Leaflet map
	     var cscale = d3.scale.linear().domain([0,1]).range(["#00FF00","#FFA500"]);
	     var mymap = L.map('mapid').setView([53.45, 14.57], 12);
	     L.tileLayer('https://api.mapbox.com/styles/v1/mnajsztub/cinwvybx6002qbunmn2hafrtp/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoibW5hanN6dHViIiwiYSI6ImNpbnd2dmxzbTAwcjR2c2tsNnBza2J2OWkifQ.3MQPtu81nKJ5aG1dkvfQag', {
		 attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery Â© <a href="http://mapbox.com">Mapbox</a>',
		 maxZoom: 18
	     }).addTo(mymap);

	     function reformat (array) {
		 var data = [];
		 array.map(function (d){
		     data.push({
			 properties: {
			     group: "dd",
			     city: "dd",
			     state: "dd",
			     store: "dd"
			 }, 
			 type: "Feature", 
			 geometry: {
			     coordinates:[+d.data_lon,+d.data_lat], 
			     type:"Point"
			 }
		     });
		 });
		 return data;
             }
             var geoData = { type: "FeatureCollection", features: reformat(coords) };
	     //**********************************************************************************
	     //********  ADD HEXBIN LAYER TO MAP AND DEFINE HEXBIN STYLE FUNCTION ***************
	     //**********************************************************************************
	     var hexLayer = L.hexbinLayer(geoData, { 
		 style: hexbinStyle,
		 mouse: makePie
             }).addTo(mymap);

	     function hexbinStyle(hexagons) {
		 hexagons
		     .attr("stroke", "black")
		     .attr("fill", function (d) {
			 var values = d.map(function (elem) {
			     return elem[2].group;
			 })
			 var avg = d3.mean(d, function(d) { return +d[2].group; })
			 return cscale(avg);
		     });
	     };
	     //**********************************************************************************
             //********  PIE CHART ROLL-OVER ****************************************************
             //**********************************************************************************
             function makePie (data) {

		 d3.select("#tooltip").selectAll(".arc").remove()
		 d3.select("#tooltip").selectAll(".pie").remove()

		 var arc = d3.svg.arc()
			     .outerRadius(45)
			     .innerRadius(10);

		 var pie = d3.layout.pie()
			     .value(function(d) { return d; });

		 var svg = d3.select("#tooltip").select("svg")
			     .append("g")
                             .attr("class", "pie")
                             .attr("transform", "translate(50,50)");

		 var g = svg.selectAll(".arc")
			    .data(pie(data))
			    .enter().append("g")
			    .attr("class", "arc");

		 g.append("path")
                  .attr("d", arc)
                  .style("fill", function(d, i) { return i === 1 ? 'orange':'green'; });

		 g.append("text")
                  .attr("transform", function(d) { return "translate(" + arc.centroid(d) + ")"; })
                  .style("text-anchor", "middle")
                  .text(function (d) { return d.value === 0 ? "" : d.value; });
             }

	     //*************************************************************** 
	     /*
		var svg = d3.select("body")
		.append("svg")
		.attr("width", w)
		.attr("height", h);
	      */
	    /* var color = d3.scale.linear()
			   .domain([0, 20])
			   .range(["white", "steelblue"])
			   .interpolate(d3.interpolateLab);

	     var hexbin = d3.hexbin()
			    .size([w, h])
			    .radius(5);
	     
	     var y = d3.scale.linear()
		       .domain([53.4, 53.6])
		       .range([0, w]);

	     var x = d3.scale.linear()
		       .domain([14.4, 14.7])
		       .range([0, h]);

	     var xAxis = d3.svg.axis()
			   .scale(x)
			   .orient("bottom")
			   .tickSize(6, -h);

	     var yAxis = d3.svg.axis()
			   .scale(y)
			   .orient("left")
			   .tickSize(6, -w);
	     
	     var svg = d3.select("body").append("svg")
			 .attr("width", w + margin.left + margin.right)
			 .attr("height", h + margin.top + margin.bottom)
			 .append("g")
			 .attr("transform", function(d) {
			     //console.log("translate(" + margin.left + "," + margin.top + ")");
			     return "translate(" + margin.left + "," + margin.top + ")";
			 });

	     svg.append("clipPath")
		.attr("id", "clip")
		.append("rect")
		.attr("class", "mesh")
		.attr("width", w)
		.attr("height", h);

	     var radius = d3.scale.sqrt()
			    .domain([0, 12])
			    .range([0, 8]);
	     
	     svg.append("g")
		.attr("clip-path", "url(#clip)")
		.selectAll(".hexagon")
		.data(hexbin(dd))
		.enter().append("path")
		.attr("class", "hexagon")
		.attr("d", hexbin.hexagon())
		.attr("transform", function(d) {
		    //console.log("translate(" + d.y + "," + d.x + ")");
		    return "translate(" + d.y + "," + d.x + ")"; })
		.style("fill", function(d) { return color(d.length); });

	     svg.append("g")
		.attr("class", "y axis")
		.call(yAxis);

	     svg.append("g")
		.attr("class", "x axis")
		.attr("transform", "translate(0," + h + ")")
		.call(xAxis);
	     */
	     
	     /*
		svg.selectAll("circle")
		.data(coords)
		.enter()
		.append("circle")
		.attr("cx", function(d) {
		return w * (d.data_lon-lon_min)/delta_lon;
		})
		.attr("cy", function(d) {
		return h - h * (d.data_lat-lat_min)/delta_lat;
		})
		.attr("r", function(d) {
		return Math.sqrt(10);
		});*/
	 });
	 
	</script>
    </body>
</html>  

