<!DOCTYPE html>
<html lang="en">
    <head>
	<style type="text/css">

	 .axis text {
	     font: 10px sans-serif;
	 }

	 .axis path,
	 .axis line {
	     fill: none;
	     stroke: #000;
	     shape-rendering: crispEdges;
	 }

	 .hexagon {
	     fill: none;
	     stroke: #000;
	     stroke-width: .5px;
	 }


	</style>
        <meta charset="utf-8">
        <title>D3 Test</title>
	<script type="text/javascript" src="{{ url_for('static', filename='d3.v3.js') }}" charset="utf-8"></script>
	<script type="text/javascript" src="{{ url_for('static', filename='d3.hexbin.min.js') }}" charset="utf-8"></script>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.2/jquery.min.js"></script>
    </head>
    <body>
	<script type="text/javascript">
	 // http://www.delimited.io/blog/2013/12/1/hexbins-with-d3-and-leaflet-maps
	 //Width and height
	 var w = 600;
	 var h = 600;
	 var margin = {top: 20, right: 20, bottom: 30, left: 40};
	 w = w - margin.right - margin.left;
	 h = h - margin.top - margin.bottom;
	 // load the external data
	 var myjson = "data";
	 d3.json(myjson, function(error, coords) {

	     var projection = d3.geo.mercator()
				.scale(70000)
				.rotate([-53.45, -14.57])
				.translate([w / 2, h / 2])
				.precision(.1);

	     console.log(projection([0,0]));
	     console.log(projection([53.4,14.55]));
	     // Summarize
	     var lat_min = d3.min(coords, function(d) {
		 return Number(d.data_lat);
	     });
	     var lat_max = d3.max(coords, function(d) {
		 return Number(d.data_lat);
	     });
	     var delta_lat = lat_max - lat_min
	 
	     var lon_min = d3.min(coords, function(d) {
		 return Number(d.data_lon);
	     });
	     var lon_max = d3.max(coords, function(d) {
		 return Number(d.data_lon);
	     });
	     var delta_lon = lon_max - lon_min
	     console.log(lat_min, lat_max);
	     console.log(lon_min, lon_max);

	     var dd = [];
	     coords.forEach(function(d) {
		 var p =projection([d.data_lat, d.data_lon]);
		// console.log(p);
		 dd.push([h-p[0], w-p[1]]);
	     }
	     );
	     //console.log(dd);
	     //Create SVG element
	     
	     
	     /*
	     var svg = d3.select("body")
			  .append("svg")
			  .attr("width", w)
			  .attr("height", h);
	     */
	     var color = d3.scale.linear()
			   .domain([0, 20])
			   .range(["white", "steelblue"])
			   .interpolate(d3.interpolateLab);

	     var hexbin = d3.hexbin()
			    .size([w, h])
			    .radius(5);
	     
	     var y = d3.scale.linear()
		       .domain([53.4, 53.6])
		       .range([0, w]);

	     var x = d3.scale.linear()
		       .domain([14.4, 14.7])
		       .range([0, h]);

	     var xAxis = d3.svg.axis()
			   .scale(x)
			   .orient("bottom")
			   .tickSize(6, -h);

	     var yAxis = d3.svg.axis()
			   .scale(y)
			   .orient("left")
			   .tickSize(6, -w);
	     
	     var svg = d3.select("body").append("svg")
			 .attr("width", w + margin.left + margin.right)
			 .attr("height", h + margin.top + margin.bottom)
			 .append("g")
			 .attr("transform", function(d) {
			     //console.log("translate(" + margin.left + "," + margin.top + ")");
			     return "translate(" + margin.left + "," + margin.top + ")";
			 });

	     svg.append("clipPath")
		.attr("id", "clip")
		.append("rect")
		.attr("class", "mesh")
		.attr("width", w)
		.attr("height", h);

	     var radius = d3.scale.sqrt()
			    .domain([0, 12])
			    .range([0, 8]);
	     
	     svg.append("g")
		.attr("clip-path", "url(#clip)")
		.selectAll(".hexagon")
		.data(hexbin(dd))
		.enter().append("path")
		.attr("class", "hexagon")
		.attr("d", hexbin.hexagon())
		.attr("transform", function(d) {
		    //console.log("translate(" + d.y + "," + d.x + ")");
		    return "translate(" + d.y + "," + d.x + ")"; })
		.style("fill", function(d) { return color(d.length); });

	     svg.append("g")
		.attr("class", "y axis")
		.call(yAxis);

	     svg.append("g")
		.attr("class", "x axis")
		.attr("transform", "translate(0," + h + ")")
		.call(xAxis);
	     
	     /*
	     svg.selectAll("circle")
		 .data(coords)
		 .enter()
		 .append("circle")
		 .attr("cx", function(d) {
		     return w * (d.data_lon-lon_min)/delta_lon;
		 })
		 .attr("cy", function(d) {
		     return h - h * (d.data_lat-lat_min)/delta_lat;
		 })
		 .attr("r", function(d) {
		     return Math.sqrt(10);
		 });*/
	 });
	 
	</script>
    </body>
</html>  
    
